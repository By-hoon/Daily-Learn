<h1 align="middle">Design Pattern</h1>

**디자인 패턴**이란 프로그램이나 어떤 특정한 것을 개발하는 중에 발생했던 문제점들을 정리해서 상황에 따라 간편하게 적용해서 쓸 수 있는 것을 정리하여 특정한 "규약"을 통해 쉽게 쓸 수 있는 형태로 만든 것을 말한다.

> # **MVC 패턴**

- ### MVC란
- ### 왜 MVC패턴을 사용해야 할까?
- ### MVC패턴의 예

<br>

## MVC란

_MVC 는 Model, View, Controller의 약자 이다. 하나의 애플리케이션, 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴이다._

사용자가 controller를 조작하면 controller는 model을 통해서 데이터를 가져오고 그 정보를 바탕으로 시각적인 표현을 담당하는 View를 제어해서 사용자에게 전달하게 된다.

<br>

> > ## 모델, Model
> >
> > 애플리케이션의 정보, 데이타를 나타낸다.

<br>

데이타베이스, 처음의 정의하는 상수, 초기화값, 변수 등을 뜻한다. 또한 이러한 DATA, 정보들의 가공을 책임지는 컴포넌트를 말한다.

<br>

모델은 다음과 같은 규칙을 가지고 있다.

- 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 한다.
- 뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야 한다.
- 변경이 일어나면, 변경 통지에 대한 처리방법을 구현해야만 한다.

  모델의 속성 중 텍스트 정보가 변경이 된다면, 이벤트를 발생시켜 누군가에게 전달해야 하며, 누군가 모델을 변경하도록 요청하는 이벤트를 보냈을 때 이를 수신할 수 있는 처리 방법을 구현해야 한다.

  또한 모델은 재사용가능해야 하며 다른 인터페이스에서도 변하지 않아야 한다.

<br>

> > ## 뷰, View
> >
> > input 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타낸다.

<br>

다시 말해 데이터 및 객체의 입력, 그리고 보여주는 출력을 담당한다.

데이타를 기반으로 사용자들이 볼 수 있는 화면이다.

<br>

뷰는 다음과 같은 규칙들이 있다.

- 모델이 가지고 있는 정보를 따로 저장해서는 안된다.
- 모델이나 컨트롤러와 같이 다른 구성요소들을 몰라야 된다.
- 변경이 일어나면 변경통지에 대한 처리방법을 구현해야만 한다.

  모델과 같이 변경이 일어났을 때 이른 누군가에게 변경을 알려줘야 하는 방법을 구현해야 한다. 뷰에서는 화면에서 사용자가 화면에 표시된 내용을 변경하게 되면 이를 모델에게 전달해서 모델을 변경해야 할 것이다. 그 작업을 하기 위해 변경 통지를 구현한다.

  그리고 재사용가능하게끔 설계를 해야 하며 다른 정보들을 표현할 때 쉽게 설계를 해야 한다.

<br>

> > ## 컨트롤러,Controller
> >
> > 데이터와 사용자인터페이스 요소들을 잇는 다리역할을 한다.

즉, 사용자가 데이터를 클릭하고, 수정하는 것에 대한 "이벤트"들을 처리하는 부분을 뜻한다.

<br>

컨트롤러는 다음과 같은 규칙을 가지고 있다.

- 모델이나 뷰에 대해서 알고 있어야 한다.

  모델이나 뷰는 서로의 존재를 모르고, 변경을 외부로 알리고, 수신하는 방법만 가지고 있는데 이를 컨트롤러가 중재하기 위해 모델과 그에 관련된 뷰에 대해서 알고 있어야 한다.

- 모델이나 뷰의 변경을 모니터링 해야 한다.

  모델이나 뷰의 변경 통지를 받으면 이를 해석해서 각각의 구성 요소에게 통지를 해야 한다.

  또한, 애플리케이션의 메인 로직은 컨트롤러가 담당하게 된다.

<br>

> ## 왜 MVC패턴을 사용해야 할까?

<br>

`사용자가 보는 페이지`, `데이터처리`, 그리고 이 2가지를 중간에서 제어하는 `컨트롤`, 이 3가지로 구성되는 하나의 애플리케이션을 만들면 각각 맡은바에만 집중을 할 수 있게 된다.

서로 분리되어 각자의 역할에 집중할 수 있게끔하여 개발을 하고 그렇게 애플리케이션을 만든다면, `유지보수성`, 애플리케이션의 `확장성`, 그리고 `유연성`이 증가하고, `중복코딩이라는 문제점 또한 사라지게 되는 것`이다.

<br>

> ## MVC패턴의 예

<br>

- 구글의 AngularJS
- php의 코드이그나이터
- python의 django

<br>

> # **JS 디자인 패턴**

- ### 싱글톤 패턴

<br>

> ## 싱글톤 패턴

<br>

### **싱글톤 패턴?**

특정 클래스의 인스턴스를 런타임동안 오직 하나만 유지하는 것을 의미한다. 자바스크립트는 클래스가 없고 *오직 객체*만 존재. 즉 새로 객체를 만들면 다른 객체와도 같지않아 이미 싱글톤이다.

```JS
var a = { k: 1 };
var b = { k: 1 };
a == b // false
a === b // false
```

값이 같아도 다른 객체 취급한다. 객체 리터럴을 이용해 객체를 생성할 때마다 싱글톤으로 만드는 것이다.

<br>

### **스태틱 프로퍼티에 인스턴스 저장**

```JS
function Singleton() {
  if (typeof Singleton.instance === "object") {
      return Singleton.instance;
    }
    // 정상적으로 진행
    this.a = 0; ..
    // 인스턴스 캐시
    Singleton.instance = this;

    return this;
}
```

클래스 프로퍼티 instance를 이용한 방법이다. instance가 공개되어 있다는 것이 단점이다. 다른 시점에서 변경될 수 있다.

<br>

### **클로저에 인스턴스 저장**

클로저를 이용해 단일 인스턴스를 보호하는 방법이다.

```JS
function Singleton() {
  // 캐싱
  let instance = this;

  // 정상적으로 진행
  this.a = 0;
  ..

  // 생성자 재작성
  Singleton = function() {
    return instance;
  }
}
```

첫 호출 시 캐싱을 하고, 클로저를 통해 생성자를 재정의한다. 다음 호출 시 재작성된 생성자로 호출되는데 클로저로 물고있는 instance를 참조한다.

    재작성된 함수는 재정의 시점 이전에 원본 생성자에 추가된 프로퍼티를 잃어버린다는 단점이 있다.

`Singleton`클래스의 프로토타입에 뭔가를 추가해도 연결되지 않는다.

```JS
Singleton.prototype.m = true;

let a = new Singleton();

Singleton.prototype.test = function() {
  return "test;
}

let b = new Singleton();
```

a,b는 미리 정의한 프로토타입 m을 가지고 있다. 한 번 호출 후 추가로 정의한 test 메서드는 반영되지 않는다.

이는 한 번 생성된 constructor가 재정의된 생성자가 아닌 원본 생성자를 가리키고 있기 때문이다.

이를 해결하기 위해서는 두 가지 방법이 있다.

- 생성자 메서드에서 prototype과 constructor를 재지정
- 즉시 실행함수로 감싸는 방법

### **생성자 메서드에서 prototype과 constructor를 재지정**

```JS
function Singleton() {
  let instance;

  Singleton = function Singleton() {
    return instance;
  }

  //prototype 프로퍼티 변경
  Singleton.prototype = this;

  instance = new Singleton();
  instance.constructor = Singleton;

  ...

  return instance;
}
```

### **즉시 실행함수로 감싸는 방법**

_비공개 instance를 가르키는 방식이다._

```JS
let Singleton;

(function() {
  let instance;

  Singleton = function Singleton() {
    if (instance) {
      return instance;
    }

    instance = this;

    ...
  };
})();
```
